import re

def extract_username_from_url(url):
    pattern = r"(?:https?:\/\/)?(?:www\.)?github\.com\/([^\/]+)\/?"
    match = re.search(pattern, url)
    if match:
        return match.group(1)
    return None

import re

def preprocess_code(code):
    # Remove comments
    code = remove_comments(code)
    
    # Remove blank lines
    code = remove_blank_lines(code)
    
    # Remove trailing whitespace
    code = remove_trailing_whitespace(code)
    
    # Normalize indentation
    code = normalize_indentation(code)
    
    # Other preprocessing steps...
    # Implement any other preprocessing steps you require
    
    preprocessed_code = code  # Assign the preprocessed code to a variable
    
    return preprocessed_code

def remove_comments(code):
    # Remove single-line comments starting with #
    code = re.sub(r'#.*', '', code)
    
    # Remove multi-line comments enclosed in /* */
    code = re.sub(r'/\*(.|[\r\n])*?\*/', '', code, flags=re.MULTILINE)
    
    return code

def remove_blank_lines(code):
    # Remove blank lines
    code = '\n'.join(line for line in code.split('\n') if line.strip())
    
    return code

def remove_trailing_whitespace(code):
    # Remove trailing whitespace from each line
    code = '\n'.join(line.rstrip() for line in code.split('\n'))
    
    return code

def normalize_indentation(code):
    # Normalize indentation to use 4 spaces
    # Example: Convert tabs to spaces or adjust indentation levels
    
    return code


def generate_prompt(code):
    return f"Analyze the technical complexity of the code:\n\n{code}"

def run_gpt_model(prompt):
    # # Load and initialize the GPT model
    # gpt = GPT()
    # gpt.load_model("path/to/your/gpt/model")

    # # Generate code evaluation using GPT
    # evaluation = gpt.generate(prompt)

    return "Evaluation generated by GPT"


def calculate_complexity_score(evaluation):
    # Analyze the evaluation to determine the complexity score
    # You can use various factors such as code patterns, structure, algorithmic complexity, etc.
    
    # Example complexity scoring logic:
    # - Count the number of lines
    line_count = len(evaluation.split('\n'))
    
    # - Count the number of function definitions
    function_count = evaluation.count('def ')
    
    # - Calculate the average line length
    lines = evaluation.split('\n')
    line_length_sum = sum(len(line) for line in lines)
    average_line_length = line_length_sum / line_count if line_count > 0 else 0
    
    # - Calculate the complexity score based on the factors
    complexity_score = line_count + function_count + average_line_length
    
    return complexity_score
